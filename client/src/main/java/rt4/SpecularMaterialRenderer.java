package rt4;

import com.jogamp.opengl.GL2;
import org.openrs2.deob.annotation.OriginalArg;
import org.openrs2.deob.annotation.OriginalClass;
import org.openrs2.deob.annotation.OriginalMember;
import org.openrs2.deob.annotation.Pc;

import java.nio.ByteBuffer;

@OriginalClass("client!vm")
public final class SpecularMaterialRenderer implements MaterialRenderer {

	// ID of the display list containing commands for OpenGL to execute upon binding this material.
	// Generated by OpenGL in constructor.
	// Note that bindMaterialCommandList + 1 is the ID of the corresponding "unbind" display list.
	@OriginalMember(owner = "client!vm", name = "a", descriptor = "I")
	private int bindMaterialCommandList = -1;

	// Set of texture ids for this material.
	// IDs are generated by OpenGL in constructor.
	// There are three cubemap textures in total, each of which is 64x64 pixels.
	@OriginalMember(owner = "client!vm", name = "c", descriptor = "[I")
	private int[] textures = null;

	// Flag that indicates whether to use the full number of textures for the material (3), 
	// or to reduce the number of textures to the minimum required by OpenGL (2).
	// In almost all cases this will be false unless you are using a truly ancient GPU.
	@OriginalMember(owner = "client!vm", name = "b", descriptor = "Z")
	private boolean useReducedTextureCount = false;

	@OriginalMember(owner = "client!vm", name = "<init>", descriptor = "()V")
	public SpecularMaterialRenderer() {
		// When supported by GPU, load texture cubemaps for simple specular highlighting.
		if (GlRenderer.arbTextureCubeMapSupported && GlRenderer.maxTextureUnits >= 2) {
			this.initializeTextureMaps();
			@Pc(19) GL2 gl = GlRenderer.gl;

			// Three textures for the three different specular highlight intensities.
			// The specific one used is selected by a call to setArgument().
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[0]);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_R, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE);
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[1]);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_R, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE);
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[2]);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_R, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE);

			// Check to see if GPU supports all three texture units for a single cubemap.
			// If not, toggle a flag to render a simplified version.
			this.useReducedTextureCount = GlRenderer.maxTextureUnits < 3;
		}

		// Initialize the OpenGL display lists containing the commands to bind/unbind this material.
		this.initializeCommandLists();
	}

	// Initializes the "bind" and "unbind" display lists,
	// which are sets of OpenGL commands that can be configured up front and then run repeatedly.
	// These command lists set up configuration for the 2-3 textures that comprise the specular material.
	@OriginalMember(owner = "client!vm", name = "d", descriptor = "()V")
	private void initializeCommandLists() {
		@Pc(1) GL2 gl = GlRenderer.gl;

		// Create two display lists of commands, one for binding the material, and one for unbinding it.
		this.bindMaterialCommandList = gl.glGenLists(2);

		// Configure bind operation.
		gl.glNewList(this.bindMaterialCommandList, GL2.GL_COMPILE);

		// If GPU doesn't support cubemaps, then there are no textures.
		// In that case we don't do anything, but we still want to sample alpha values
		// from the fragment instead of from the currently-bound texture,
		// since we don't have any textures bound that could cause a problem.
		if (this.textures == null) {
			gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_PRIMARY_COLOR);
		} else {
			// Three textures in total need to be configured.
			// Texture0 is the default texture, presumably configured by caller to contain albedo color.
			// Texture1 is the specular highlight contained in one of the three pre-created cubemap textures.
			// Texture2 I'm not sure about, might be some extra effect created by caller.

			// Configure texture 1 (the specular highlight).
			gl.glActiveTexture(GL2.GL_TEXTURE1);

			// I think this takes the texture, which places the highlight along the top/left
			// of the cubemap, and aligns its texture coordinates along the normal of the fragment
			// so that the highlight is flush with the mesh surface.
			gl.glTexGeni(GL2.GL_S, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_NORMAL_MAP);
			gl.glTexGeni(GL2.GL_T, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_NORMAL_MAP);
			gl.glTexGeni(GL2.GL_R, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_NORMAL_MAP);
			gl.glEnable(GL2.GL_TEXTURE_GEN_S);
			gl.glEnable(GL2.GL_TEXTURE_GEN_T);
			gl.glEnable(GL2.GL_TEXTURE_GEN_R);
			gl.glEnable(GL2.GL_TEXTURE_CUBE_MAP);

			// Rotate the texture 22.5 degrees about the X axis (why?)
			gl.glMatrixMode(GL2.GL_TEXTURE);
			gl.glLoadIdentity();
			gl.glRotatef(22.5F, 1.0F, 0.0F, 0.0F);
			gl.glMatrixMode(GL2.GL_MODELVIEW);

			// Define how the textures are mixed together in the shader.
			// There are two options for this depending on GPU, full shading and reduced shading.
			// First is reduced shading (which should be pretty rare).
			// Don't know enough about fixed function shading to understand the details yet.
			if (this.useReducedTextureCount) {
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_ADD);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_OPERAND0_RGB, GL2.GL_SRC_ALPHA);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_REPLACE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_PRIMARY_COLOR);
			} else {
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_REPLACE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_RGB, GL2.GL_PREVIOUS);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_MODULATE);
				gl.glActiveTexture(GL2.GL_TEXTURE2);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_TEXTURE_ENV_MODE, GL2.GL_COMBINE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_ADD);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_RGB, GL2.GL_PREVIOUS);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC1_RGB, GL2.GL_PREVIOUS);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_OPERAND1_RGB, GL2.GL_SRC_ALPHA);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_REPLACE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_PRIMARY_COLOR);
				gl.glBindTexture(GL2.GL_TEXTURE_2D, GlRenderer.anInt5328);
				gl.glEnable(GL2.GL_TEXTURE_2D);
			}

			// Restore default texture0.
			gl.glActiveTexture(GL2.GL_TEXTURE0);
		}
		gl.glEndList();

		// Configure unbind operation.
		// Reverts everything from above bind operation and restores previous values.
		gl.glNewList(this.bindMaterialCommandList + 1, GL2.GL_COMPILE);
		if (this.textures == null) {
			gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_TEXTURE);
		} else {
			gl.glActiveTexture(GL2.GL_TEXTURE1);
			gl.glDisable(GL2.GL_TEXTURE_GEN_S);
			gl.glDisable(GL2.GL_TEXTURE_GEN_T);
			gl.glDisable(GL2.GL_TEXTURE_GEN_R);
			gl.glDisable(GL2.GL_TEXTURE_CUBE_MAP);
			gl.glMatrixMode(GL2.GL_TEXTURE);
			gl.glLoadIdentity();
			gl.glMatrixMode(GL2.GL_MODELVIEW);
			if (this.useReducedTextureCount) {
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_OPERAND0_RGB, GL2.GL_SRC_COLOR);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_TEXTURE);
			} else {
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_RGB, GL2.GL_TEXTURE);
				gl.glActiveTexture(GL2.GL_TEXTURE2);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_TEXTURE_ENV_MODE, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_RGB, GL2.GL_TEXTURE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_OPERAND1_RGB, GL2.GL_SRC_COLOR);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_TEXTURE);
				gl.glDisable(GL2.GL_TEXTURE_2D);
			}
			gl.glActiveTexture(GL2.GL_TEXTURE0);
		}
		gl.glEndList();
	}

	@OriginalMember(owner = "client!vm", name = "a", descriptor = "()V")
	@Override
	public final void unbind() {
		@Pc(1) GL2 gl = GlRenderer.gl;
		if (Preferences.highDetailLighting) {
			gl.glCallList(this.bindMaterialCommandList + 1);
		} else {
			gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_TEXTURE);
		}
	}

	// Retrieves flags for specular rendering.
	// For specular materials, texture combine alpha mode is disabled 
	// since we handle it specially in the call to bind().
	@OriginalMember(owner = "client!vm", name = "c", descriptor = "()I")
	@Override
	public final int getFlags() {
		return 4;
	}

	@OriginalMember(owner = "client!vm", name = "b", descriptor = "()V")
	@Override
	public final void bind() {
		@Pc(1) GL2 gl = GlRenderer.gl;
		GlRenderer.setTextureCombineAlphaMode(1);
		if (Preferences.highDetailLighting) {
			gl.glCallList(this.bindMaterialCommandList);
		} else {
			gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_PRIMARY_COLOR);
		}
	}

	// Sets the argument for the material renderer.
	// For specular materials, the argument represents the intensity of highlight
	// within a range from 1-3, where 1 is the brightest and 3 is the dimmest.
	@OriginalMember(owner = "client!vm", name = "a", descriptor = "(I)V")
	@Override
	public final void setArgument(@OriginalArg(0) int arg0) {
		@Pc(1) GL2 gl = GlRenderer.gl;

		// Do nothing if unsupported by GPU or disabled in preferences.
		if (Preferences.highDetailLighting && this.textures != null) {
			// Texture1 contains the specular highlight texture.
			// We select the texture matching the requested argument and bind it to texture1.
			gl.glActiveTexture(GL2.GL_TEXTURE1);
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[arg0 - 1]);
			gl.glActiveTexture(GL2.GL_TEXTURE0);
		}
	}

	@OriginalMember(owner = "client!vm", name = "e", descriptor = "()V")
	private void initializeTextureMaps() {
		@Pc(1) GL2 gl = GlRenderer.gl;

		// Generate 3 new textures.
		if (this.textures == null) {
			this.textures = new int[3];
			gl.glGenTextures(3, this.textures, 0);
		}

		// Generate byte data to store in each texture buffer.
		@Pc(19) byte[] texture2 = new byte[4096];
		@Pc(22) byte[] texture0 = new byte[4096];
		@Pc(25) byte[] texture1 = new byte[4096];

		// Data for each face is generated sequentially (right, left, top, bottom, back, front).
		// Each face is a 64x64 square.
		for (@Pc(27) int cubeFace = 0; cubeFace < 6; cubeFace++) {
			@Pc(32) int index = 0;
			for (@Pc(34) int y = 0; y < 64; y++) {
				for (@Pc(39) int x = 0; x < 64; x++) {
					// Compute a 3D vector that points from origin to the point on cubeFace at (x,y).
					@Pc(51) float xNormalized = (float) x * 2.0F / 64.0F - 1.0F;
					@Pc(60) float yNormalized = (float) y * 2.0F / 64.0F - 1.0F;
					@Pc(75) float vectorLen = (float) (1.0D / Math.sqrt(xNormalized * xNormalized + yNormalized * yNormalized + 1.0F));
					@Pc(79) float vectorX = xNormalized * vectorLen;
					@Pc(83) float vectorY = yNormalized * vectorLen;
					@Pc(88) float vector;
					if (cubeFace == 0) { // Right face
						vector = -vectorX;
					} else if (cubeFace == 1) { // Left face
						vector = vectorX;
					} else if (cubeFace == 2) { // Top face
						vector = vectorY;
					} else if (cubeFace == 3) { // Bottom face
						vector = -vectorY;
					} else if (cubeFace == 4) { // Back face
						vector = vectorLen;
					} else { // Front face
						vector = -vectorLen;
					}

					// Compute three specular highlights of different intensities.
					@Pc(129) int color0;
					@Pc(137) int color1;
					@Pc(145) int color2;

					// Top/left/back corner of cube is "highlighted" with a specular light.
					// This light can have one of three intensities, depending on the material.
					// Rest of the cubemap is left at zero.
					if (vector > 0.0F) {
						color0 = (int) (Math.pow(vector, 96.0D) * 255.0D);
						color1 = (int) (Math.pow(vector, 36.0D) * 255.0D);
						color2 = (int) (Math.pow(vector, 12.0D) * 255.0D);
					} else {
						color2 = 0;
						color1 = 0;
						color0 = 0;
					}

					if (GlRenderer.maxTextureUnits < 3) {
						color0 /= 5;
						color1 /= 5;
						color2 /= 5;
					} else {
						color0 /= 2;
						color1 /= 2;
						color2 /= 2;
					}

					texture0[index] = (byte) color0;
					texture1[index] = (byte) color1;
					texture2[index] = (byte) color2;
					index++;
				}
			}

			// Copy each texture's data to its corresponding texture buffer.
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[0]);
			gl.glTexImage2D(cubeFace + GL2.GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL2.GL_ALPHA, 64, 64, 0, GL2.GL_ALPHA, GL2.GL_UNSIGNED_BYTE, ByteBuffer.wrap(texture0));
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[1]);
			gl.glTexImage2D(cubeFace + GL2.GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL2.GL_ALPHA, 64, 64, 0, GL2.GL_ALPHA, GL2.GL_UNSIGNED_BYTE, ByteBuffer.wrap(texture1));
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[2]);
			gl.glTexImage2D(cubeFace + GL2.GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL2.GL_ALPHA, 64, 64, 0, GL2.GL_ALPHA, GL2.GL_UNSIGNED_BYTE, ByteBuffer.wrap(texture2));

			// Update the high watermark for memory consumed by textures (3 * 4096 = 12288).
			GlCleaner.onCardTexture += 12288;
		}
	}
}
