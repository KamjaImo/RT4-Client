package rt4;

import com.jogamp.opengl.GL2;
import org.openrs2.deob.annotation.OriginalArg;
import org.openrs2.deob.annotation.OriginalClass;
import org.openrs2.deob.annotation.OriginalMember;
import org.openrs2.deob.annotation.Pc;

import java.nio.ByteBuffer;

@OriginalClass("client!vm")
public final class SpecularMaterialRenderer implements MaterialRenderer {

	@OriginalMember(owner = "client!vm", name = "a", descriptor = "I")
	private int anInt5777 = -1;

	// Set of texture ids for this material.
	// IDs are generated by OpenGL in constructor.
	// There are three cubemap textures in total, each of which is 64x64 pixels.
	@OriginalMember(owner = "client!vm", name = "c", descriptor = "[I")
	private int[] textures = null;

	@OriginalMember(owner = "client!vm", name = "b", descriptor = "Z")
	private boolean aBoolean301 = false;

	@OriginalMember(owner = "client!vm", name = "<init>", descriptor = "()V")
	public SpecularMaterialRenderer() {
		if (GlRenderer.arbTextureCubeMapSupported && GlRenderer.maxTextureUnits >= 2) {
			this.initializeTextureMaps();
			@Pc(19) GL2 gl = GlRenderer.gl;
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[0]);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_R, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE);
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[1]);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_R, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE);
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[2]);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_R, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE);
			gl.glTexParameteri(GL2.GL_TEXTURE_CUBE_MAP, GL2.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE);
			this.aBoolean301 = GlRenderer.maxTextureUnits < 3;
		}
		this.initializeCommandLists();
	}

	@OriginalMember(owner = "client!vm", name = "d", descriptor = "()V")
	private void initializeCommandLists() {
		@Pc(1) GL2 gl = GlRenderer.gl;
		this.anInt5777 = gl.glGenLists(2);
		gl.glNewList(this.anInt5777, GL2.GL_COMPILE);
		if (this.textures == null) {
			gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_PRIMARY_COLOR);
		} else {
			gl.glActiveTexture(GL2.GL_TEXTURE1);
			gl.glTexGeni(GL2.GL_S, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_NORMAL_MAP);
			gl.glTexGeni(GL2.GL_T, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_NORMAL_MAP);
			gl.glTexGeni(GL2.GL_R, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_NORMAL_MAP);
			gl.glEnable(GL2.GL_TEXTURE_GEN_S);
			gl.glEnable(GL2.GL_TEXTURE_GEN_T);
			gl.glEnable(GL2.GL_TEXTURE_GEN_R);
			gl.glEnable(GL2.GL_TEXTURE_CUBE_MAP);
			gl.glMatrixMode(GL2.GL_TEXTURE);
			gl.glLoadIdentity();
			gl.glRotatef(22.5F, 1.0F, 0.0F, 0.0F);
			gl.glMatrixMode(GL2.GL_MODELVIEW);
			if (this.aBoolean301) {
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_ADD);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_OPERAND0_RGB, GL2.GL_SRC_ALPHA);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_REPLACE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_PRIMARY_COLOR);
			} else {
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_REPLACE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_RGB, GL2.GL_PREVIOUS);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_MODULATE);
				gl.glActiveTexture(GL2.GL_TEXTURE2);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_TEXTURE_ENV_MODE, GL2.GL_COMBINE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_ADD);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_RGB, GL2.GL_PREVIOUS);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC1_RGB, GL2.GL_PREVIOUS);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_OPERAND1_RGB, GL2.GL_SRC_ALPHA);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_REPLACE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_PRIMARY_COLOR);
				gl.glBindTexture(GL2.GL_TEXTURE_2D, GlRenderer.anInt5328);
				gl.glEnable(GL2.GL_TEXTURE_2D);
			}
			gl.glActiveTexture(GL2.GL_TEXTURE0);
		}
		gl.glEndList();
		gl.glNewList(this.anInt5777 + 1, GL2.GL_COMPILE);
		if (this.textures == null) {
			gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_TEXTURE);
		} else {
			gl.glActiveTexture(GL2.GL_TEXTURE1);
			gl.glDisable(GL2.GL_TEXTURE_GEN_S);
			gl.glDisable(GL2.GL_TEXTURE_GEN_T);
			gl.glDisable(GL2.GL_TEXTURE_GEN_R);
			gl.glDisable(GL2.GL_TEXTURE_CUBE_MAP);
			gl.glMatrixMode(GL2.GL_TEXTURE);
			gl.glLoadIdentity();
			gl.glMatrixMode(GL2.GL_MODELVIEW);
			if (this.aBoolean301) {
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_OPERAND0_RGB, GL2.GL_SRC_COLOR);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_TEXTURE);
			} else {
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_RGB, GL2.GL_TEXTURE);
				gl.glActiveTexture(GL2.GL_TEXTURE2);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_TEXTURE_ENV_MODE, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_RGB, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_RGB, GL2.GL_TEXTURE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_OPERAND1_RGB, GL2.GL_SRC_COLOR);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_COMBINE_ALPHA, GL2.GL_MODULATE);
				gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_TEXTURE);
				gl.glDisable(GL2.GL_TEXTURE_2D);
			}
			gl.glActiveTexture(GL2.GL_TEXTURE0);
		}
		gl.glEndList();
	}

	@OriginalMember(owner = "client!vm", name = "a", descriptor = "()V")
	@Override
	public final void unbind() {
		@Pc(1) GL2 gl = GlRenderer.gl;
		if (Preferences.highDetailLighting) {
			gl.glCallList(this.anInt5777 + 1);
		} else {
			gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_TEXTURE);
		}
	}

	@OriginalMember(owner = "client!vm", name = "c", descriptor = "()I")
	@Override
	public final int getFlags() {
		return 4;
	}

	@OriginalMember(owner = "client!vm", name = "b", descriptor = "()V")
	@Override
	public final void bind() {
		@Pc(1) GL2 gl = GlRenderer.gl;
		GlRenderer.setTextureCombineAlphaMode(1);
		if (Preferences.highDetailLighting) {
			gl.glCallList(this.anInt5777);
		} else {
			gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_SRC0_ALPHA, GL2.GL_PRIMARY_COLOR);
		}
	}

	@OriginalMember(owner = "client!vm", name = "a", descriptor = "(I)V")
	@Override
	public final void setArgument(@OriginalArg(0) int arg0) {
		@Pc(1) GL2 gl = GlRenderer.gl;
		if (Preferences.highDetailLighting && this.textures != null) {
			gl.glActiveTexture(GL2.GL_TEXTURE1);
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[arg0 - 1]);
			gl.glActiveTexture(GL2.GL_TEXTURE0);
		}
	}

	@OriginalMember(owner = "client!vm", name = "e", descriptor = "()V")
	private void initializeTextureMaps() {
		@Pc(1) GL2 gl = GlRenderer.gl;

		// Generate 3 new textures.
		if (this.textures == null) {
			this.textures = new int[3];
			gl.glGenTextures(3, this.textures, 0);
		}

		// Generate byte data to store in each texture buffer.
		@Pc(19) byte[] texture2 = new byte[4096];
		@Pc(22) byte[] texture0 = new byte[4096];
		@Pc(25) byte[] texture1 = new byte[4096];

		// Data for each face is generated sequentially (right, left, top, bottom, back, front).
		// Each face is a 64x64 square.
		for (@Pc(27) int cubeFace = 0; cubeFace < 6; cubeFace++) {
			@Pc(32) int index = 0;
			for (@Pc(34) int y = 0; y < 64; y++) {
				for (@Pc(39) int x = 0; x < 64; x++) {
					// Compute a 3D vector that points from origin to the point on cubeFace at (x,y).
					@Pc(51) float xNormalized = (float) x * 2.0F / 64.0F - 1.0F;
					@Pc(60) float yNormalized = (float) y * 2.0F / 64.0F - 1.0F;
					@Pc(75) float vectorLen = (float) (1.0D / Math.sqrt(xNormalized * xNormalized + yNormalized * yNormalized + 1.0F));
					@Pc(79) float vectorX = xNormalized * vectorLen;
					@Pc(83) float vectorY = yNormalized * vectorLen;
					@Pc(88) float vector;
					if (cubeFace == 0) { // Right face
						vector = -vectorX;
					} else if (cubeFace == 1) { // Left face
						vector = vectorX;
					} else if (cubeFace == 2) { // Top face
						vector = vectorY;
					} else if (cubeFace == 3) { // Bottom face
						vector = -vectorY;
					} else if (cubeFace == 4) { // Back face
						vector = vectorLen;
					} else { // Front face
						vector = -vectorLen;
					}

					// Compute three gradients of different intensities.
					@Pc(129) int color0;
					@Pc(137) int color1;
					@Pc(145) int color2;

					// Top/left/back corner of cube is "highlighted" with three gradient effects.
					// Rest of the cubemap is left at zero.
					if (vector > 0.0F) {
						color0 = (int) (Math.pow(vector, 96.0D) * 255.0D);
						color1 = (int) (Math.pow(vector, 36.0D) * 255.0D);
						color2 = (int) (Math.pow(vector, 12.0D) * 255.0D);
					} else {
						color2 = 0;
						color1 = 0;
						color0 = 0;
					}

					if (GlRenderer.maxTextureUnits < 3) {
						color0 /= 5;
						color1 /= 5;
						color2 /= 5;
					} else {
						color0 /= 2;
						color1 /= 2;
						color2 /= 2;
					}

					texture0[index] = (byte) color0;
					texture1[index] = (byte) color1;
					texture2[index] = (byte) color2;
					index++;
				}
			}

			// Copy each texture's data to its corresponding texture buffer.
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[0]);
			gl.glTexImage2D(cubeFace + GL2.GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL2.GL_ALPHA, 64, 64, 0, GL2.GL_ALPHA, GL2.GL_UNSIGNED_BYTE, ByteBuffer.wrap(texture0));
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[1]);
			gl.glTexImage2D(cubeFace + GL2.GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL2.GL_ALPHA, 64, 64, 0, GL2.GL_ALPHA, GL2.GL_UNSIGNED_BYTE, ByteBuffer.wrap(texture1));
			gl.glBindTexture(GL2.GL_TEXTURE_CUBE_MAP, this.textures[2]);
			gl.glTexImage2D(cubeFace + GL2.GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL2.GL_ALPHA, 64, 64, 0, GL2.GL_ALPHA, GL2.GL_UNSIGNED_BYTE, ByteBuffer.wrap(texture2));

			// Update the high watermark for memory consumed by textures (3 * 4096 = 12288).
			GlCleaner.onCardTexture += 12288;
		}
	}
}
